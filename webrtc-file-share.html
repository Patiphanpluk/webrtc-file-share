<!DOCTYPE html>
<html lang="th">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>ส่งไฟล์ P2P (WebRTC)</title>
<style>
  body{font-family:system-ui,Arial;max-width:900px;margin:24px auto;padding:12px}
  .box{border:1px solid #ddd;padding:12px;border-radius:8px;margin-bottom:12px}
  progress{width:100%}
  #log{white-space:pre-wrap;background:#f8f8f8;padding:8px;border-radius:6px;max-height:160px;overflow:auto}
  button{margin-right:8px}
</style>
</head>
<body>
<h1>แชร์ไฟล์ข้ามอุปกรณ์ (P2P)</h1>
<div class="box">
  <label>Signaling server URL (WebSocket): <input id="wsUrl" value="ws://localhost:3000" style="width:60%"></label>
  <div style="margin-top:8px">
    <button id="connectBtn">เชื่อมต่อ signaling</button>
    <button id="createBtn" disabled>สร้างห้อง (เป็น caller)</button>
    <button id="joinBtn" disabled>เข้าร่วมห้อง (เป็น callee)</button>
    <input id="roomId" placeholder="รหัสห้อง (เช่น: room123)" style="width:200px;margin-left:8px">
  </div>
</div>

<div class="box">
  <input type="file" id="fileInput" />
  <div style="margin-top:8px">
    <button id="sendBtn" disabled>ส่งไฟล์</button>
    <span id="fileInfo"></span>
  </div>
  <div style="margin-top:8px">
    <label>Upload progress</label>
    <progress id="sendProgress" value="0" max="100"></progress>
  </div>
</div>

<div class="box">
  <label>Download progress</label>
  <progress id="recvProgress" value="0" max="100"></progress>
  <div id="receivedFiles"></div>
</div>

<div class="box">
  <div id="log"></div>
</div>

<script>
const logEl = id('log');
function log(...a){ logEl.textContent += a.join(' ') + '\n'; logEl.scrollTop = logEl.scrollHeight; }
function id(s){ return document.getElementById(s); }

let ws, pc, dc;
let fileToSend = null;
let ROOM = null;

id('connectBtn').onclick = async () => {
  const url = id('wsUrl').value;
  ws = new WebSocket(url);
  ws.onopen = () => {
    log('WebSocket connected');
    id('createBtn').disabled = id('joinBtn').disabled = false;
  };
  ws.onmessage = async (ev) => {
    const msg = JSON.parse(ev.data);
    log('WS<-', JSON.stringify(msg));
    if(msg.type === 'offer') {
      await ensurePeer();
      await pc.setRemoteDescription(msg.offer);
      const answer = await pc.createAnswer();
      await pc.setLocalDescription(answer);
      ws.send(JSON.stringify({type:'answer', answer, room: msg.room}));
      log('Sent answer');
    } else if(msg.type === 'answer') {
      await pc.setRemoteDescription(msg.answer);
      log('Received answer');
    } else if(msg.type === 'ice') {
      try{
        await pc.addIceCandidate(msg.candidate);
      }catch(e){ console.warn(e); }
    }
  };
  ws.onerror = e => log('WS error', e);
};

id('createBtn').onclick = async () => {
  ROOM = id('roomId').value || ('room-' + Math.random().toString(36).slice(2,8));
  await ensurePeer();
  dc = pc.createDataChannel('file');
  setupDataChannel(dc);
  const offer = await pc.createOffer();
  await pc.setLocalDescription(offer);
  ws.send(JSON.stringify({type:'offer', offer, room: ROOM}));
  log('Created offer for room', ROOM);
  id('sendBtn').disabled = false;
};

id('joinBtn').onclick = async () => {
  ROOM = id('roomId').value;
  if(!ROOM){ alert('ใส่รหัสห้องก่อน'); return; }
  await ensurePeer();
  id('sendBtn').disabled = false;
  log('Joining room', ROOM);
  // server will forward the offer -> we will receive 'offer' via ws.onmessage
};

// ensure peer connection exists
async function ensurePeer(){
  if(pc) return;
  pc = new RTCPeerConnection();
  pc.onicecandidate = e => {
    if(e.candidate) ws.send(JSON.stringify({type:'ice', candidate: e.candidate, room: ROOM}));
  };
  pc.ondatachannel = e => {
    dc = e.channel;
    setupDataChannel(dc);
  };
}

// DataChannel handlers: chunked file transfer
function setupDataChannel(channel){
  channel.binaryType = 'arraybuffer';
  channel.onopen = () => log('DataChannel open');
  channel.onclose = () => log('DataChannel closed');
  channel.onerror = e => log('DC error', e);
  let incoming = {buffers: [], filename: '', size: 0, received: 0};
  channel.onmessage = (e) => {
    const msg = e.data;
    if(typeof msg === 'string'){
      // control messages encoded as JSON
      try{
        const obj = JSON.parse(msg);
        if(obj.type === 'meta'){
          incoming.filename = obj.name;
          incoming.size = obj.size;
          incoming.buffers = [];
          incoming.received = 0;
          id('recvProgress').value = 0;
          log('Incoming file', obj.name, obj.size);
        } else if(obj.type === 'end'){
          // assemble
          const blob = new Blob(incoming.buffers);
          const a = document.createElement('a');
          a.href = URL.createObjectURL(blob);
          a.download = incoming.filename || 'download';
          a.textContent = 'ดาวน์โหลด: ' + (incoming.filename || 'file');
          const div = document.createElement('div');
          div.appendChild(a);
          id('receivedFiles').appendChild(div);
          log('File received:', incoming.filename);
          incoming = {buffers: [], filename: '', size: 0, received: 0};
          id('recvProgress').value = 0;
        }
      }catch(err){ console.warn(err); }
    } else {
      // ArrayBuffer chunk
      incoming.buffers.push(msg);
      incoming.received += msg.byteLength;
      if(incoming.size) id('recvProgress').value = Math.floor(incoming.received / incoming.size * 100);
    }
  };
}

// send file in chunks
id('sendBtn').onclick = async () => {
  if(!dc || dc.readyState !== 'open'){ alert('DataChannel ยังไม่เปิด'); return; }
  const f = id('fileInput').files[0];
  if(!f){ alert('เลือกไฟล์ก่อน'); return; }
  const chunkSize = 64 * 1024; // 64KB
  id('fileInfo').textContent = `ส่ง: ${f.name} (${f.size} bytes)`;
  dc.send(JSON.stringify({type:'meta', name: f.name, size: f.size}));
  const stream = f.stream ? f.stream() : null;
  if(stream){ // modern stream API
    const reader = stream.getReader();
    let sent = 0;
    while(true){
      const {done, value} = await reader.read();
      if(done) break;
      dc.send(value);
      sent += value.byteLength;
      id('sendProgress').value = Math.floor(sent / f.size * 100);
    }
  } else {
    // fallback: slice
    let offset = 0;
    let sent = 0;
    while(offset < f.size){
      const slice = f.slice(offset, offset + chunkSize);
      const ab = await slice.arrayBuffer();
      dc.send(ab);
      offset += chunkSize;
      sent += ab.byteLength;
      id('sendProgress').value = Math.floor(sent / f.size * 100);
      await new Promise(r => setTimeout(r, 0)); // let event loop breathe
    }
  }
  dc.send(JSON.stringify({type:'end'}));
  log('ส่งไฟล์เสร็จ:', f.name);
};

// helper: allow paste of local offer/answer? (we use ws for signaling so not necessary)
</script>
</body>
</html>
